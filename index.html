<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>제크와 콩의 요정 v4.3</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Jua&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Jua', sans-serif;
            touch-action: none;
            overflow: hidden;
            margin: 0;
        }
        canvas {
            background-color: #87CEEB;
            cursor: crosshair;
            display: block;
            margin: 0 auto;
            width: 100%;
        }
        .modal-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 50;
        }
        .modal-content {
            background: white;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            color: #333;
        }
        .restart-btn {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1.2em;
            cursor: pointer;
            margin-top: 20px;
        }
        .instructions h3 {
            font-size: 1.5rem;
            color: #4ade80;
            margin-bottom: 1rem;
            border-bottom: 2px solid #4ade80;
            padding-bottom: 0.5rem;
        }
        .instructions p, .instructions li {
            font-size: 1rem;
            line-height: 1.6;
            margin-bottom: 0.75rem;
        }
        .instructions ul {
            list-style-position: inside;
            padding-left: 0.5rem;
        }
    </style>
</head>
<body class="bg-gray-800 flex items-start justify-center h-screen relative">
<div class="w-full h-full flex flex-col lg:flex-row items-center justify-start p-0 gap-0">
    <div id="gameWrapper" class="relative mx-auto">
        <div id="infoPanel" class="text-white text-center p-4 rounded-t-lg bg-gray-900">
            <h1 class="text-2xl font-bold">제크와 콩의 요정</h1>
            <div class="flex justify-around mt-2">
                <p>Wave <span id="wave">1</span></p>
                <p>높이: <span id="score">0</span> m</p>
                <p>❤️ <span id="heartCount">0</span></p>
                <p>🪙 <span id="coinCount">0</span></p>
                <p>💣 <span id="bombCount">3</span></p>
            </div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="guideText" class="absolute left-1/2 -translate-x-1/2 text-white text-lg bg-black bg-opacity-50 px-3 py-1 rounded pointer-events-none hidden" style="top:30%;">이동할 수 있게 가지를 이어 주세요.</div>
        <img id="touchGuideLeft" src="https://i.imgur.com/hTCAWgp.png" alt="touch guide" class="guide-image absolute hidden w-16 h-16 pointer-events-none" style="top:50%; left:37.5%; transform:translate(-50%,-50%);"/>
        <img id="touchGuideRight" src="https://i.imgur.com/hTCAWgp.png" alt="touch guide" class="guide-image absolute hidden w-16 h-16 pointer-events-none" style="top:50%; left:62.5%; transform:translate(-50%,-50%);"/>
        <div id="bombContainer" class="absolute bottom-4 left-4 flex items-center space-x-2">
            <div class="w-14 h-14 bg-white rounded flex items-center justify-center">
                <img id="bombButton" src="https://i.imgur.com/zmV2iL4.png" class="w-10 h-10 cursor-pointer" alt="bomb"/>
            </div>
            <span class="text-white text-xl">x<span id="bombCountDisplay">3</span></span>
        </div>
        <div id="levelInfo" class="absolute bottom-4 right-4 text-white text-xl bg-gray-900 bg-opacity-50 px-3 py-1 rounded">
            Lv.<span id="level">1</span> ❤️ <span id="currentHearts">0</span>/<span id="heartsNeeded">1</span>
        </div>
        <div id="levelUpText" class="hidden absolute inset-0 flex items-center justify-center text-4xl text-yellow-300 font-bold pointer-events-none">레벨 업!</div>
        <div id="waveText" class="hidden absolute inset-0 flex items-center justify-center text-4xl text-white font-bold pointer-events-none"></div>
        <div id="flash" class="hidden fixed top-0 left-0 w-full h-full bg-white opacity-70"></div>
    </div>
    <div class="w-full lg:w-1/3 max-w-md bg-gray-900 text-white p-6 rounded-lg instructions hidden lg:block">
        <h3>🎮 게임 방법</h3>
        <p><strong>1. 가지 만들기:</strong> 마우스를 클릭해서 콩나무 줄기 사이에 <strong>가지</strong>를 만들어 제크가 다른 줄기로 이동할 수 있게 도와주세요.</p>
        <p><strong>2. 벌레 피하기:</strong> 하늘에서 떨어지는 <strong>벌레</strong>에 닿으면 게임이 종료되니 조심하세요!</p>
        <p><strong>3. 아이템 획득:</strong></p>
        <ul>
            <li><strong>코인(🪙):</strong> 최대한 많이 모아보세요!</li>
            <li><strong>하트(❤️):</strong> 획득한 하트 개수가 기록돼요.</li>
            <li><strong>폭탄(💣):</strong> 화면 하단 폭탄을 충전해요.</li>
            <li><strong>자석:</strong> 화면의 코인과 몬스터를 모두 끌어당겨 코인으로 만들어요.</li>
        </ul>
    </div>
</div>
<div id="gameOverModal" class="hidden modal-bg">
    <div class="modal-content">
        <h2 class="text-3xl font-bold mb-4">게임 오버!</h2>
        <p class="text-xl">최고 높이: <span id="finalScore">0</span> m</p>
        <p class="text-xl">획득한 하트: <span id="finalHeartCount">0</span> 개</p>
        <p class="text-xl">획득한 코인: <span id="finalCoinCount">0</span> 개</p>
        <div class="mt-4">
            <h3 class="text-lg font-bold mb-2">랭킹</h3>
            <ol id="rankingList" class="text-left text-base"></ol>
            <p id="playerRank" class="mt-2 font-bold"></p>
        </div>
        <button id="restartButton" class="restart-btn mt-4">다시 시작</button>
    </div>
</div>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const heartCountEl = document.getElementById('heartCount');
const coinCountEl = document.getElementById('coinCount');
const bombCountEl = document.getElementById('bombCount');
const bombCountDisplay = document.getElementById('bombCountDisplay');
const gameOverModal = document.getElementById('gameOverModal');
const finalScoreEl = document.getElementById('finalScore');
const finalHeartCountEl = document.getElementById('finalHeartCount');
const finalCoinCountEl = document.getElementById('finalCoinCount');
const rankingListEl = document.getElementById('rankingList');
const playerRankEl = document.getElementById('playerRank');
const restartButton = document.getElementById('restartButton');
const bombButton = document.getElementById('bombButton');
const flashEl = document.getElementById('flash');
const guideTextEl = document.getElementById('guideText');
const guideImageLeft = document.getElementById('touchGuideLeft');
const guideImageRight = document.getElementById('touchGuideRight');
const guideImageEls = [guideImageLeft, guideImageRight];
const levelEl = document.getElementById('level');
const currentHeartsEl = document.getElementById('currentHearts');
const heartsNeededEl = document.getElementById('heartsNeeded');
const levelUpTextEl = document.getElementById('levelUpText');
const waveEl = document.getElementById('wave');
const waveTextEl = document.getElementById('waveText');
let guideTimeout;
const bgm = new Audio('https://raw.githubusercontent.com/jangunsoul/Idea-webpage01/main/The%20Cheetahmen.mp3');
bgm.loop = true;
window.addEventListener('pointerdown', () => bgm.play(), { once: true });
const coinSfx = new Audio('https://raw.githubusercontent.com/jangunsoul/Idea-webpage01/main/CoinGet.wav');
window.addEventListener('pointerdown', () => {
    coinSfx.play().then(() => {
        coinSfx.pause();
        coinSfx.currentTime = 0;
    }).catch(() => {});
}, { once: true });
let canvasWidth, canvasHeight;
const aspectRatio = 9 / 16;
let score = 0, totalDistance = 0, heartCount = 0, coinCount = 0, bombCount = 3;
let gameSpeed = 2, isGameOver = false, animationFrameId;
const beanstalkCount = 3;
const beanstalkPositions = [];
const maxBugs = 8;
let bugSpawnInterval = 2000;
let lastBugSpawnTime = 0;
let stoneSpawnInterval = 10000;
let lastStoneSpawnTime = 0;
const magnetSpawnInterval = 15000;
let lastMagnetSpawnTime = 0;
let isMagnetActive = false;
let magnetCoinGain = 0;
let coinMessage = '';
let coinMessageTime = 0;
let wave = 1;
let waveDuration = 60000;
let waveStartTime = Date.now();

const jackImage = new Image();
let isJackImageLoaded = false;
jackImage.src = 'https://i.imgur.com/Xzd5Spc.png';
jackImage.onload = () => { isJackImageLoaded = true; };

const beanstalkImage = new Image();
let isBeanstalkImageLoaded = false;
beanstalkImage.src = 'https://i.imgur.com/pegdl9L.png';
beanstalkImage.onload = () => { isBeanstalkImageLoaded = true; };

const coinImage = new Image();
let isCoinImageLoaded = false;
coinImage.src = 'https://i.imgur.com/V6Vb5EL.png';
coinImage.onload = () => { isCoinImageLoaded = true; };

const bugImage = new Image();
let isBugImageLoaded = false;
bugImage.src = 'https://i.imgur.com/W4FzmCC.png';
bugImage.onload = () => { isBugImageLoaded = true; };

const bombImage = new Image();
let isBombImageLoaded = false;
bombImage.src = 'https://i.imgur.com/zmV2iL4.png';
bombImage.onload = () => { isBombImageLoaded = true; };

const stoneImage = new Image();
let isStoneImageLoaded = false;
stoneImage.src = 'https://i.imgur.com/Asv1GN4.png';
stoneImage.onload = () => { isStoneImageLoaded = true; };

const magnetImage = new Image();
magnetImage.crossOrigin = 'anonymous';
let isMagnetImageLoaded = false;
magnetImage.onload = () => { isMagnetImageLoaded = true; };
magnetImage.src = 'https://i.imgur.com/Z9Pc9Yk.gif';
magnetImage.style.display = 'none';
document.body.appendChild(magnetImage);

const jack = { width:40, height:40, x:0, y:0, speed:gameSpeed, stalkIndex:1, isMovingHorizontally:false, targetX:0, color:'#2ecc71' };
let bugs = [], stones = [], branches = [], clouds = [], items = [], coins = [], bullets = [];
const bugBaseHp = 10;
let bugLevel = 1;
let bugMaxHp = bugBaseHp;
const bulletSpeed = 8;
const baseBulletDamage = 4;
const baseBulletWidth = 4;
const baseBulletHeight = 8;
let bulletDamage = baseBulletDamage;
let bulletWidth = baseBulletWidth;
let bulletHeight = baseBulletHeight;
let bulletColor = 'yellow';
const shootInterval = 1000;
let lastShotTime = 0;
let level = 1;
let heartsNeeded = 1;

function updateBulletStats() {
    bulletDamage = Math.round(baseBulletDamage * Math.pow(1.3, level - 1));
    const scale = 1 + 0.05 * (level - 1);
    bulletWidth = baseBulletWidth * scale;
    bulletHeight = baseBulletHeight * scale;
    bulletColor = `hsl(${(level * 25) % 360}, 100%, 50%)`;
}

function showLevelUpEffect() {
    levelUpTextEl.classList.remove('hidden');
    setTimeout(() => levelUpTextEl.classList.add('hidden'), 1000);
}

function checkLevelUp() {
    while (level < 99 && heartCount >= heartsNeeded) {
        level++;
        heartsNeeded *= 2;
        updateBulletStats();
        levelEl.textContent = level;
        heartsNeededEl.textContent = heartsNeeded;
        showLevelUpEffect();
    }
}

function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function announceWave() {
    waveTextEl.textContent = `[Wave ${wave}]`;
    waveTextEl.classList.remove('hidden');
    setTimeout(() => waveTextEl.classList.add('hidden'), 2000);
}

function startNextWave() {
    wave++;
    waveEl.textContent = wave;
    bugLevel = wave;
    bugMaxHp = Math.round(bugBaseHp * Math.pow(1.3, bugLevel - 1));
    waveDuration = 60000 + (wave - 1) * 10000;
    waveStartTime = Date.now();
    announceWave();
}

function setCanvasDimensions() {
    const infoHeight = document.getElementById('infoPanel').offsetHeight;
    let availableWidth = window.innerWidth;
    let availableHeight = window.innerHeight - infoHeight;

    let heightByWidth = availableWidth / aspectRatio;
    if (heightByWidth > availableHeight) {
        canvasHeight = availableHeight;
        canvasWidth = availableHeight * aspectRatio;
    } else {
        canvasWidth = availableWidth;
        canvasHeight = heightByWidth;
    }

    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    canvas.style.width = canvasWidth + 'px';
    canvas.style.height = canvasHeight + 'px';

    const wrapper = document.getElementById('gameWrapper');
    wrapper.style.width = canvasWidth + 'px';
    wrapper.style.height = canvasHeight + infoHeight + 'px';
}

function positionGuideImages() {
    const infoHeight = document.getElementById('infoPanel').offsetHeight;
    const top = infoHeight + canvasHeight * 0.4;
    guideImageLeft.style.top = top + 'px';
    guideImageRight.style.top = top + 'px';
    if (beanstalkPositions.length >= 3) {
        guideImageLeft.style.left = (beanstalkPositions[0] + beanstalkPositions[1]) / 2 + 'px';
        guideImageRight.style.left = (beanstalkPositions[1] + beanstalkPositions[2]) / 2 + 'px';
    }
}

function init() {
    isGameOver = false;
    score = 0;
    totalDistance = 0;
    heartCount = 0;
    coinCount = 0;
    bombCount = 3;
    coinMessage = '';
    coinMessageTime = 0;
    magnetCoinGain = 0;
    level = 1;
    heartsNeeded = 1;
    updateBulletStats();
    wave = 1;
    waveDuration = 60000;
    waveStartTime = Date.now();
    waveEl.textContent = wave;
    bugLevel = 1;
    bugMaxHp = bugBaseHp;
    gameSpeed = 2;
    bugs = [];
    stones = [];
    branches = [];
    clouds = [];
    items = [];
    coins = [];
    bullets = [];
    lastBugSpawnTime = 0;
    bugSpawnInterval = 2000;
    lastStoneSpawnTime = 0;
    stoneSpawnInterval = 10000;
    lastMagnetSpawnTime = Date.now();
    isMagnetActive = false;
    lastShotTime = 0;

    beanstalkPositions.length = 0;
    for (let i = 0; i < beanstalkCount; i++) {
        beanstalkPositions.push((canvasWidth / (beanstalkCount + 1)) * (i + 1));
    }

    jack.stalkIndex = 1;
    jack.x = beanstalkPositions[jack.stalkIndex] - jack.width / 2;
    jack.y = canvasHeight - jack.height - 20;
    jack.isMovingHorizontally = false;
    positionGuideImages();

    scoreEl.textContent = 0;
    heartCountEl.textContent = 0;
    coinCountEl.textContent = 0;
    bombCountEl.textContent = bombCount;
    bombCountDisplay.textContent = bombCount;
    levelEl.textContent = level;
    heartsNeededEl.textContent = heartsNeeded;
    currentHeartsEl.textContent = heartCount;
    guideTextEl.classList.add('hidden');
    guideImageEls.forEach(el => el.classList.add('hidden'));
    gameOverModal.classList.add('hidden');

    announceWave();

    for (let i = 0; i < 5; i++) spawnCloud(true);
    if (animationFrameId) cancelAnimationFrame(animationFrameId);
    gameLoop();
    startGuideTimer();
}

function spawnCloud(isInitial = false) {
    clouds.push({
        x: Math.random() * canvasWidth,
        y: isInitial ? Math.random() * canvasHeight : -60,
        radius: 20 + Math.random() * 25,
        speed: 0.5 + Math.random() * 0.5
    });
}

function spawnBug() {
    const now = Date.now();
    if (bugs.length < maxBugs && now - lastBugSpawnTime > bugSpawnInterval) {
        lastBugSpawnTime = now;
        const stalkIndex = Math.floor(Math.random() * beanstalkCount);
        const bugSize = 60;
        bugs.push({
            x: beanstalkPositions[stalkIndex] - bugSize/2,
            y: -bugSize,
            width: bugSize,
            height: bugSize,
            speed: gameSpeed * (0.8 + Math.random() * 0.7),
            color: '#e74c3c',
            hp: bugMaxHp,
            maxHp: bugMaxHp,
            level: bugLevel
        });
        bugSpawnInterval = Math.max(500, 2000 - score * 5);
    }
}

function spawnStone() {
    const now = Date.now();
    if (now - lastStoneSpawnTime > stoneSpawnInterval) {
        lastStoneSpawnTime = now;
        stoneSpawnInterval = Math.max(1000, stoneSpawnInterval - 100);
        const stalkIndex = jack.stalkIndex;
        const size = 60;
        stones.push({
            x: beanstalkPositions[stalkIndex] - size/2,
            y: -size,
            width: size,
            height: size,
            speed: gameSpeed * (0.8 + Math.random() * 0.7)
        });
    }
}

function spawnStalkItem() {
    if (Math.random() < 0.005) {
        const stalkIndex = Math.floor(Math.random() * beanstalkCount);
        const itemSize = 40;
        const r = Math.random();
        if (r < 0.1) {
            items.push({ x: beanstalkPositions[stalkIndex] - itemSize/2, y: -itemSize, width: itemSize, height: itemSize, type: 'bomb', speed: gameSpeed * 0.6 });
        } else if (r < 0.55) {
            let amount = 1;
            let isBonus = false;
            if (Math.random() < 0.1) { amount = randInt(2,6); isBonus = true; }
            items.push({ x: beanstalkPositions[stalkIndex] - itemSize/2, y: -itemSize, width: itemSize, height: itemSize, type: 'heart', amount, speed: gameSpeed * 0.6, isBonus });
        } else {
            let amount = 1;
            let isBonus = false;
            if (Math.random() < 0.1) { amount = randInt(2,15); isBonus = true; }
            coins.push({ x: beanstalkPositions[stalkIndex] - itemSize/2, y: -itemSize, width: itemSize, height: itemSize, speed: gameSpeed * 0.6, amount, isBonus });
        }
    }
}

function dropLoot(bug) {
    if (Math.random() < 0.5) {
        const size = 40;
        const amount = randInt(1,3);
        const isBonus = amount > 1;
        items.push({ x: bug.x + bug.width/2 - size/2, y: bug.y, width: size, height: size, type: 'heart', amount, speed: gameSpeed * 0.6, isBonus });
    } else {
        const size = 30;
        const amount = randInt(5,10);
        coins.push({ x: bug.x + bug.width/2 - size/2, y: bug.y, width: size, height: size, speed: gameSpeed * 0.7, amount, isBonus: true });
    }
}

function manageCoins() {
    const targetCoinCount = 12;
    if (coins.length < targetCoinCount && Math.random() < 0.1) {
        const stalkIndex = Math.floor(Math.random() * beanstalkCount);
        const coinSize = 30;
        coins.push({ x: beanstalkPositions[stalkIndex] - coinSize/2, y: -coinSize, width: coinSize, height: coinSize, speed: gameSpeed * 0.7, amount: 1, isBonus: false });
    }
}

function spawnMagnetItem() {
    const now = Date.now();
    const hasMagnet = items.some(it => it.type === 'magnet');
    if (!hasMagnet && now - lastMagnetSpawnTime > magnetSpawnInterval) {
        lastMagnetSpawnTime = now;
        const itemSize = 60;
        const indices = [];
        for (let i = 0; i < beanstalkCount; i++) if (i !== jack.stalkIndex) indices.push(i);
        const stalkIndex = indices[Math.floor(Math.random() * indices.length)];
        items.push({ x: beanstalkPositions[stalkIndex] - itemSize/2, y: -itemSize, width: itemSize, height: itemSize, type: 'magnet', speed: gameSpeed * 0.6 });
    }
}

function activateMagnet() {
    isMagnetActive = true;
    magnetCoinGain = 0;
    coins.forEach(c => c.speed = 0);
    bugs.forEach(bug => {
        const size = 30;
        const amount = randInt(3,6);
        coins.push({ x: bug.x + bug.width/2 - size/2, y: bug.y + bug.height/2 - size/2, width: size, height: size, speed: 0, amount, isBonus: true });
    });
    bugs = [];
    stones.forEach(stone => {
        const size = 30;
        const amount = randInt(3,6);
        coins.push({ x: stone.x + stone.width/2 - size/2, y: stone.y + stone.height/2 - size/2, width: size, height: size, speed: 0, amount, isBonus: true });
    });
    stones = [];
}

function shootBullet() {
    bullets.push({
        x: jack.x + jack.width / 2 - bulletWidth / 2,
        y: jack.y,
        width: bulletWidth,
        height: bulletHeight,
        speed: bulletSpeed,
        color: bulletColor,
        damage: bulletDamage
    });
    lastShotTime = Date.now();
}

function startGuideTimer() {
    clearTimeout(guideTimeout);
    guideTimeout = setTimeout(() => {
        guideTextEl.classList.remove('hidden');
        guideImageEls.forEach(el => el.classList.remove('hidden'));
    }, 2000);
}

function handleUserInput() {
    guideTextEl.classList.add('hidden');
    guideImageEls.forEach(el => el.classList.add('hidden'));
    startGuideTimer();
}

function createBranch(e) {
    handleUserInput();

    const rect = canvas.getBoundingClientRect();
    const clientX = e.clientX || e.touches[0].clientX;
    const clientY = e.clientY || e.touches[0].clientY;
    const x = clientX - rect.left;
    const y = clientY - rect.top;

    let fromStalk = -1, toStalk = -1;
    for (let i = 0; i < beanstalkCount - 1; i++) {
        if (x > beanstalkPositions[i] && x < beanstalkPositions[i + 1]) {
            if (jack.stalkIndex === i) { fromStalk = i; toStalk = i + 1; }
            else if (jack.stalkIndex === i + 1) { fromStalk = i + 1; toStalk = i; }
            break;
        }
    }

    if (fromStalk !== -1) {
        const fromX = beanstalkPositions[fromStalk];
        const toX = beanstalkPositions[toStalk];
        const tooClose = branches.some(b => {
            const sameGap = (b.x1 === fromX && b.x2 === toX) || (b.x1 === toX && b.x2 === fromX);
            return sameGap && Math.abs(b.y1 - y) < jack.height;
        });
        if (!tooClose) {
            branches.push({ x1: fromX, y1: y, x2: toX, y2: y, color: '#8B4513', used: false });
            if (Math.random() < 0.25) {
                const itemSize = 40;
                if (Math.random() < 0.5) {
                    let amount = 1;
                    let isBonus = false;
                    if (Math.random() < 0.1) { amount = randInt(2,6); isBonus = true; }
                    items.push({ x: (fromX + toX) / 2 - itemSize/2, y: y - itemSize/2, width: itemSize, height: itemSize, type: 'heart', amount, speed: 0, isBonus });
                } else {
                    let amount = 1;
                    let isBonus = false;
                    if (Math.random() < 0.1) { amount = randInt(2,15); isBonus = true; }
                    coins.push({ x: (fromX + toX) / 2 - itemSize/2, y: y - itemSize/2, width: itemSize, height: itemSize, speed: 0, amount, isBonus });
                }
            }
        }
    }
}

function useBomb() {
    if (bombCount <= 0 || isGameOver) return;
    bombCount--;
    bombCountEl.textContent = bombCount;
    bombCountDisplay.textContent = bombCount;
    flashEl.classList.remove('hidden');
    setTimeout(() => flashEl.classList.add('hidden'), 200);
    bugs = [];
    stones = [];
}

function update() {
    if (isGameOver) return;

    if (isMagnetActive) {
        let allCollected = true;
        for (let i = coins.length - 1; i >= 0; i--) {
            const coin = coins[i];
            const tx = jack.x + jack.width / 2 - coin.width / 2;
            const ty = jack.y + jack.height / 2 - coin.height / 2;
            const dx = tx - coin.x;
            const dy = ty - coin.y;
            const dist = Math.hypot(dx, dy);
            if (dist > 5) {
                coin.x += dx * 0.2;
                coin.y += dy * 0.2;
                allCollected = false;
            } else {
                const amount = coin.amount || 1;
                coinCount += amount;
                magnetCoinGain += amount;
                coinCountEl.textContent = coinCount;
                coinSfx.currentTime = 0;
                coinSfx.play();
                coins.splice(i, 1);
            }
        }
        if (allCollected) {
            isMagnetActive = false;
            if (magnetCoinGain > 0) {
                coinMessage = `+${magnetCoinGain} COIN GET!`;
                coinMessageTime = Date.now();
            }
        }
        return;
    }

    const now = Date.now();
    if (now - waveStartTime > waveDuration) {
        startNextWave();
    }

    if (jack.isMovingHorizontally) {
        const dx = jack.targetX - jack.x;
        if (Math.abs(dx) < 5) {
            jack.x = jack.targetX;
            jack.isMovingHorizontally = false;
        } else {
            jack.x += dx * 0.1;
        }
    } else {
        jack.y -= jack.speed;
    }

    if (!jack.isMovingHorizontally && now - lastShotTime > shootInterval) {
        shootBullet();
    }

    let scrollAmount = 0;
    const scrollThreshold = canvasHeight * 2 / 3;
    if (jack.y < scrollThreshold) {
        scrollAmount = scrollThreshold - jack.y;
        jack.y = scrollThreshold;
        branches.forEach(b => { b.y1 += scrollAmount; b.y2 += scrollAmount; });
        bugs.forEach(bug => bug.y += scrollAmount);
        stones.forEach(stone => stone.y += scrollAmount);
        clouds.forEach(c => c.y += scrollAmount * c.speed * 0.5);
        items.forEach(item => item.y += scrollAmount);
        coins.forEach(coin => coin.y += scrollAmount);
        bullets.forEach(b => b.y += scrollAmount);
        totalDistance += scrollAmount;
    }

    score = Math.floor(totalDistance / 10);
    gameSpeed = 2 + (score / 500);
    jack.speed = gameSpeed;
    scoreEl.textContent = score;

    bugs = bugs.filter(bug => bug.y < canvasHeight + 50);
    stones = stones.filter(stone => stone.y < canvasHeight + 50);
    items = items.filter(item => item.y < canvasHeight + 50);
    coins = coins.filter(coin => coin.y < canvasHeight + 50);
    branches = branches.filter(b => b.y1 < canvasHeight + 20);
    clouds = clouds.filter(c => c.y < canvasHeight + c.radius);
    if (Math.random() < 0.01) spawnCloud();

    for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.y -= b.speed;
        if (b.y + b.height < 0 || b.y > canvasHeight) {
            bullets.splice(i, 1);
        }
    }

    const jackCenterX = jack.x + jack.width / 2;
    const jackCenterY = jack.y + jack.height / 2;

    for (let i = bugs.length - 1; i >= 0; i--) {
        const bug = bugs[i];
        bug.y += bug.speed;
        for (let j = bullets.length - 1; j >= 0; j--) {
            const bullet = bullets[j];
            if (bullet.x < bug.x + bug.width && bullet.x + bullet.width > bug.x && bullet.y < bug.y + bug.height && bullet.y + bullet.height > bug.y) {
                bug.hp -= bullet.damage;
                bullets.splice(j, 1);
                if (bug.hp <= 0) {
                    dropLoot(bug);
                    bugs.splice(i, 1);
                }
                break;
            }
        }
        const bugCenterX = bug.x + bug.width / 2;
        const bugCenterY = bug.y + bug.height / 2;
        if (Math.abs(jackCenterX - bugCenterX) < 5 && Math.abs(jackCenterY - bugCenterY) < 5) gameOver();
    }

    for (let i = stones.length - 1; i >= 0; i--) {
        const stone = stones[i];
        stone.y += stone.speed;
        for (let j = bullets.length - 1; j >= 0; j--) {
            const bullet = bullets[j];
            if (bullet.x < stone.x + stone.width && bullet.x + bullet.width > stone.x && bullet.y < stone.y + stone.height && bullet.y + bullet.height > stone.y) {
                bullets.splice(j, 1);
                break;
            }
        }
        const stoneCenterX = stone.x + stone.width / 2;
        const stoneCenterY = stone.y + stone.height / 2;
        if (Math.abs(jackCenterX - stoneCenterX) < 5 && Math.abs(jackCenterY - stoneCenterY) < 5) gameOver();
    }

    for (let i = items.length - 1; i >= 0; i--) {
        const item = items[i];
        if (item.speed) item.y += item.speed;
        if (jack.x < item.x + item.width && jack.x + jack.width > item.x && jack.y < item.y + item.height && jack.y + jack.height > item.y) {
            if (item.type === 'heart') {
                heartCount += item.amount || 1;
                heartCountEl.textContent = heartCount;
                currentHeartsEl.textContent = heartCount;
                checkLevelUp();
            } else if (item.type === 'bomb') {
                bombCount++;
                bombCountEl.textContent = bombCount;
                bombCountDisplay.textContent = bombCount;
            } else if (item.type === 'magnet') {
                activateMagnet();
                lastMagnetSpawnTime = Date.now();
            }
            items.splice(i, 1);
        }
    }

    for (let i = coins.length - 1; i >= 0; i--) {
        const coin = coins[i];
        if (coin.speed) coin.y += coin.speed;
        if (jack.x < coin.x + coin.width && jack.x + jack.width > coin.x && jack.y < coin.y + coin.height && jack.y + jack.height > coin.y) {
            const amount = coin.amount || 1;
            coinCount += amount;
            coinCountEl.textContent = coinCount;
            coinMessage = `+${amount} COIN GET!`;
            coinMessageTime = Date.now();
            coinSfx.currentTime = 0;
            coinSfx.play();
            coins.splice(i, 1);
        }
    }

    if (!jack.isMovingHorizontally) {
        branches.forEach(branch => {
            if (!branch.used && jack.y < branch.y1 && (jack.y + jack.height) > branch.y1) {
                if (beanstalkPositions[jack.stalkIndex] === branch.x1) {
                    branch.used = true;
                    jack.isMovingHorizontally = true;
                    jack.stalkIndex = beanstalkPositions.indexOf(branch.x2);
                    jack.targetX = beanstalkPositions[jack.stalkIndex] - jack.width / 2;
                } else if (beanstalkPositions[jack.stalkIndex] === branch.x2) {
                    branch.used = true;
                    jack.isMovingHorizontally = true;
                    jack.stalkIndex = beanstalkPositions.indexOf(branch.x1);
                    jack.targetX = beanstalkPositions[jack.stalkIndex] - jack.width / 2;
                }
            }
        });
    }

    spawnBug();
    spawnStone();
    spawnStalkItem();
    manageCoins();
    spawnMagnetItem();
}

function draw() {
    if (isGameOver) return;
    ctx.clearRect(0,0,canvasWidth,canvasHeight);

    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    clouds.forEach(c => { ctx.beginPath(); ctx.arc(c.x, c.y, c.radius, 0, Math.PI * 2); ctx.fill(); });

    if (isBeanstalkImageLoaded) {
        const stalkWidth = 30;
        const imgHeight = beanstalkImage.height;
        if (imgHeight > 0) {
            beanstalkPositions.forEach(pos => {
                const yOffset = totalDistance % imgHeight;
                for (let y = yOffset - imgHeight; y < canvasHeight; y += imgHeight) {
                    ctx.drawImage(beanstalkImage, pos - stalkWidth/2, y, stalkWidth, imgHeight);
                }
            });
        }
    } else {
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 10;
        beanstalkPositions.forEach(pos => { ctx.beginPath(); ctx.moveTo(pos,0); ctx.lineTo(pos,canvasHeight); ctx.stroke(); });
    }

    ctx.lineWidth = 8;
    branches.forEach(b => { ctx.strokeStyle = b.color; ctx.beginPath(); ctx.moveTo(b.x1, b.y1); ctx.lineTo(b.x2, b.y2); ctx.stroke(); });

    items.forEach(item => {
        const cx = item.x + item.width / 2;
        const cy = item.y + item.height / 2;
        const amountScale = item.amount && item.amount > 1 ? 1 + 0.1 * item.amount : 1;
        const bonusScale = item.isBonus ? 1.05 + 0.05 * Math.sin(Date.now() / 200) : 1;
        const scale = amountScale * bonusScale;
        ctx.save();
        ctx.translate(cx, cy);
        ctx.scale(scale, scale);
        ctx.translate(-item.width / 2, -item.height / 2);
        if (item.type === 'heart') {
            ctx.fillStyle = '#e91e63';
            ctx.beginPath();
            const d = Math.min(item.width, item.height);
            const k = 0;
            const l = 0;
            ctx.moveTo(k, l + d/4);
            ctx.quadraticCurveTo(k, l, k + d/4, l);
            ctx.quadraticCurveTo(k + d/2, l, k + d/2, l + d/4);
            ctx.quadraticCurveTo(k + d/2, l, k + d*3/4, l);
            ctx.quadraticCurveTo(k + d, l, k + d, l + d/4);
            ctx.quadraticCurveTo(k + d, l + d/2, k + d*3/4, l + d*3/4);
            ctx.lineTo(k + d/2, l + d);
            ctx.lineTo(k + d/4, l + d*3/4);
            ctx.quadraticCurveTo(k, l + d/2, k, l + d/4);
            ctx.fill();
        } else if (item.type === 'bomb') {
            if (isBombImageLoaded) {
                ctx.drawImage(bombImage, 0, 0, item.width, item.height);
            } else {
                ctx.fillStyle = 'red';
                ctx.beginPath();
                ctx.arc(item.width/2, item.height/2, item.width/2, 0, Math.PI * 2);
                ctx.fill();
            }
        } else if (item.type === 'magnet') {
            if (isMagnetImageLoaded) {
                ctx.drawImage(magnetImage, 0, 0, item.width, item.height);
            } else {
                ctx.fillStyle = 'purple';
                ctx.fillRect(0, 0, item.width, item.height);
            }
        }
        ctx.restore();
        if (item.amount && item.amount > 1) {
            ctx.fillStyle = 'white';
            ctx.font = '12px Jua';
            ctx.textAlign = 'center';
            ctx.fillText(`x${item.amount}`, cx, item.y - 5);
        }
    });

    coins.forEach(coin => {
        const cx = coin.x + coin.width / 2;
        const cy = coin.y + coin.height / 2;
        const amountScale = coin.amount > 1 ? 1 + 0.1 * coin.amount : 1;
        const bonusScale = coin.isBonus ? 1.05 + 0.05 * Math.sin(Date.now() / 200) : 1;
        const scale = amountScale * bonusScale;
        ctx.save();
        ctx.translate(cx, cy);
        ctx.scale(scale, scale);
        ctx.translate(-coin.width / 2, -coin.height / 2);
        if (isCoinImageLoaded) {
            ctx.drawImage(coinImage, 0, 0, coin.width, coin.height);
        } else {
            ctx.fillStyle = 'gold';
            ctx.beginPath();
            ctx.arc(coin.width/2, coin.height/2, coin.width/2, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();
        if (coin.amount && coin.amount > 1) {
            ctx.fillStyle = 'white';
            ctx.font = '12px Jua';
            ctx.textAlign = 'center';
            ctx.fillText(`x${coin.amount}`, cx, coin.y - 5);
        }
    });

    bullets.forEach(b => {
        ctx.fillStyle = b.color;
        ctx.fillRect(b.x, b.y, b.width, b.height);
    });

    stones.forEach(s => {
        if (isStoneImageLoaded) {
            ctx.drawImage(stoneImage, s.x, s.y, s.width, s.height);
        } else {
            ctx.fillStyle = '#555';
            ctx.fillRect(s.x, s.y, s.width, s.height);
        }
    });

    bugs.forEach(b => {
        if (isBugImageLoaded) {
            ctx.drawImage(bugImage, b.x, b.y, b.width, b.height);
        } else {
            ctx.fillStyle = b.color;
            ctx.fillRect(b.x, b.y, b.width, b.height);
        }
        const barHeight = 5;
        ctx.fillStyle = 'red';
        ctx.fillRect(b.x, b.y - barHeight - 2, b.width, barHeight);
        ctx.fillStyle = 'green';
        ctx.fillRect(b.x, b.y - barHeight - 2, b.width * (b.hp / b.maxHp), barHeight);
        ctx.fillStyle = 'white';
        ctx.font = '12px Jua';
        ctx.textAlign = 'center';
        ctx.fillText(`Lv.${b.level}`, b.x + b.width/2, b.y - barHeight - 4);
    });

    if (isJackImageLoaded) {
        ctx.drawImage(jackImage, jack.x, jack.y, jack.width, jack.height);
    } else {
        ctx.fillStyle = jack.color;
        ctx.fillRect(jack.x, jack.y, jack.width, jack.height);
    }

    if (coinMessage) {
        if (Date.now() - coinMessageTime < 1000) {
            ctx.fillStyle = 'yellow';
            ctx.font = '16px Jua';
            ctx.textAlign = 'center';
            ctx.fillText(coinMessage, jack.x + jack.width / 2, jack.y - 10);
        } else {
            coinMessage = '';
        }
    }

}

function gameLoop() {
    update();
    draw();
    animationFrameId = requestAnimationFrame(gameLoop);
}

function updateRanking() {
    const entry = { score: score, time: Date.now() };
    const records = JSON.parse(localStorage.getItem('records') || '[]');
    records.push(entry);
    records.sort((a, b) => b.score - a.score);
    const playerRank = records.findIndex(r => r.time === entry.time) + 1;
    localStorage.setItem('records', JSON.stringify(records));
    rankingListEl.innerHTML = '';
    records.slice(0, 10).forEach((r, i) => {
        const li = document.createElement('li');
        li.textContent = `${i + 1}. ${r.score} m`;
        rankingListEl.appendChild(li);
    });
    playerRankEl.textContent = `현재 순위: ${playerRank}위`;
}

function gameOver() {
    isGameOver = true;
    cancelAnimationFrame(animationFrameId);
    finalScoreEl.textContent = score;
    finalHeartCountEl.textContent = heartCount;
    finalCoinCountEl.textContent = coinCount;
    updateRanking();
    gameOverModal.classList.remove('hidden');
}

canvas.addEventListener('click', createBranch);
canvas.addEventListener('touchstart', createBranch, { passive: true });
window.addEventListener('pointerdown', handleUserInput);
window.addEventListener('pointermove', handleUserInput);
restartButton.addEventListener('click', () => { setCanvasDimensions(); init(); });
window.addEventListener('resize', () => { setCanvasDimensions(); init(); });
bombButton.addEventListener('click', useBomb);

setCanvasDimensions();
init();
</script>
</body>
</html>